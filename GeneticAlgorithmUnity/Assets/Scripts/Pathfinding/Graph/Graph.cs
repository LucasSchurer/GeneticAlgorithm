using Game.Events;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Game.Pathfinding
{
    public class Graph : MonoBehaviour
    {
        /* https://gist.github.com/GibsS/fdba8e3cdbd307652fc3c01336b32534 */
        public static int CantorPairing(int i, int j) => (((i + j) * (i + j + 1)) / 2) + j;
        public static void ReverseCantorPairing(int m, out int i, out int j)
        {
            int t = (int)Math.Floor((-1 + Math.Sqrt(1 + 8 * m)) * 0.5f);
            i = t * (t + 3) / 2 - m;
            j = m - t * (t + 1) / 2;
        }

        [SerializeField]
        private MapSettings _settings;

        [SerializeField]
        private Transform _centerTransform;

        private int _gridRowCount;
        private int _gridColumnCount;
        private Vector3 _startingPosition;
        public int GridRowCount => _gridRowCount;
        public int GridColumnCount => _gridColumnCount;

        // The size of the vertex. It's used to retrieve a vertex based on mouse position, for example.
        private float _vertexSize;
        private float _vertexSpacing;

        // The key for the dictionary is a unique number generated by a cantor pairing function
        // using which row and column the vertex is positioned on the grid.
        private Dictionary<int, Vertex> _vertices;
        public Dictionary<int, Vertex> Vertices => _vertices;
        public int VerticesCount => _vertices.Count;

        /// <summary>
        /// Check if the given row and column indexes are contained in the grid.
        /// </summary>
        /// <param name="rowIndex"></param>
        /// <param name="columnIndex"></param>
        /// <returns></returns>
        public bool IsIndexValid(int rowIndex, int columnIndex) => rowIndex >= 0 && rowIndex < _gridRowCount && columnIndex >= 0 && columnIndex < _gridColumnCount;

        private void Awake()
        {
            _vertexSize = _settings.VertexSize;

            _gridRowCount = Mathf.CeilToInt(_settings.GridSize.y / (_vertexSize + _vertexSpacing));
            _gridColumnCount = Mathf.CeilToInt(_settings.GridSize.x / (_vertexSize + _vertexSpacing));
            _vertices = new Dictionary<int, Vertex>(_gridRowCount * _gridColumnCount);

            _startingPosition = new Vector3(_centerTransform.position.x - ((_vertexSize + _vertexSpacing) * _gridColumnCount) * 0.5f, 
                                            _centerTransform.position.y, 
                                            _centerTransform.position.z - ((_vertexSize + _vertexSpacing) * _gridColumnCount) * 0.5f);

            GenerateGraph();
        }

        private void Update()
        {
            _vertices.Clear();
            Awake();
        }

        /// <summary>
        /// Create and add a vertex to the dictionary based on the given row and column.
        /// The grid will be used to determine the terrain type of the vertex.
        /// </summary>
        /// <param name="row"></param>
        /// <param name="column"></param>
        /// <returns></returns>
        public Vertex CreateVertex(int row, int column, bool shouldCreateWalls = true)
        {
            if (IsIndexValid(row, column))
            {
                int identifier = CantorPairing(row, column);

                if (!_vertices.ContainsKey(identifier))
                {
                    Vector3 vertexPosition = _startingPosition;
                    vertexPosition.x += column * _vertexSize + _vertexSize / 2 + _vertexSpacing * column;
                    vertexPosition.z += row * _vertexSize + _vertexSize / 2 + _vertexSpacing * row;

                    MapSettings.TerrainSettings t = GetTerrainSettingsOnPosition(vertexPosition, _vertexSize);

/*                    if (t.terrainType == TerrainType.None)
                    {
                        return null;
                    }*/

                    Vertex createdVertex = new Vertex(identifier, row, column, vertexPosition, _vertexSize, t.terrainType, t.terrainPenalty);

                    _vertices.Add(createdVertex.Identifier, createdVertex);

                    return createdVertex;
                }
            }

            return null;
        }

        private MapSettings.TerrainSettings GetTerrainSettingsOnPosition(Vector3 position, float size)
        {
            foreach (MapSettings.TerrainSettings t in _settings.GetTerrainSettings)
            {
                size = size / 2;

                Collider[] hits = Physics.OverlapBox(position, new Vector3(size, size, size), Quaternion.identity, t.layerMask);

                if (hits.Length > 0)
                {
                    return t;
                }
                else
                {
                    continue;
                }
            }

            return new MapSettings.TerrainSettings() { terrainType = TerrainType.None };
        }

        public Vertex CreateVertex(int identifier, bool shouldCreateWalls = true)
        {
            int row;
            int column;

            ReverseCantorPairing(identifier, out row, out column);

            return CreateVertex(row, column, shouldCreateWalls);
        }

        /// <summary>
        /// Remove a vertex from the dictionary and remove all of its connections.
        /// </summary>
        /// <param name="vertex"></param>
        public void RemoveVertex(Vertex vertex)
        {
            if (_vertices.ContainsKey(vertex.Identifier))
            {
                foreach (Vertex connectedVertex in vertex.GetConnectedVertices())
                {
                    connectedVertex.RemoveConnectedVertex(vertex);
                }

                _vertices.Remove(vertex.Identifier);
            }
        }

        /// <summary>
        /// Get a vertex based on a given world position.
        /// </summary>
        /// <param name="position"></param>
        /// <returns>
        /// Return the vertex if there is a vertex on the position or null if not.
        /// </returns>
        public Vertex GetVertexOnPosition(Vector3 position)
        {
            int rowIndex = (int)((position.z - _startingPosition.z) / _vertexSize);
            int columnIndex = (int)((position.x - _startingPosition.x) / _vertexSize);

            Vertex vertex;

            if (_vertices.TryGetValue(CantorPairing(rowIndex, columnIndex), out vertex))
            {
                return vertex;
            }

            return null;
        }

        private void GenerateGraph()
        {
            CreateVertices();
            CreateEdges();
        }

        private void CreateVertices()
        {
            for (int i = 0; i < _gridRowCount; i++)
            {
                for (int j = 0; j < _gridColumnCount; j++)
                {
                    CreateVertex(i, j, true);
                }
            }
        }

        private void CreateEdges()
        {
            foreach (Vertex vertex in _vertices.Values)
            {
                if (vertex.TerrainType != TerrainType.NonWalkable)
                {
                    foreach (Vertex neighbour in GetVertexNeighbours(vertex))
                    {
                        vertex.ConnectTo(neighbour);
                    }
                }
            }
        }

        private Vertex GetVertex(int rowIndex, int columnIndex)
        {
            if (IsIndexValid(rowIndex, columnIndex))
            {
                Vertex vertex;
                _vertices.TryGetValue(CantorPairing(rowIndex, columnIndex), out vertex);

                return vertex;
            }
            else
            {
                return null;
            }
        }

        public Vertex GetVertex(int identifier)
        {
            int row;
            int column;

            ReverseCantorPairing(identifier, out row, out column);

            return GetVertex(row, column);
        }

        /// <summary>
        /// Get all valid vertices surrounding a given vertex.
        /// </summary>
        /// For a neighbour be considered valid
        /// it must be:
        /// TerrainType != Wall
        /// If its a diagonal neighbour, we must check if there
        /// is a way that the vertex can access that neighbour. 
        /// <example>
        /// [0, W, 2]
        /// [3, 4, W]
        /// [6, 7, 8]
        /// W = Walls
        /// N = Vertex Identifier
        /// 
        /// Checking the neighbours of vertex 4.
        /// 3 and 7 are valid cardinal neighbours.
        /// 0, 6 and 8 are valid diagonal neighbours.
        /// 2 is invalid because there is no way you can access 2 from 4.
        /// There are two walls blocking the passage.
        /// </example>
        /// <param name="vertex"></param>
        /// <returns></returns>
        private Vertex[] GetVertexNeighbours(Vertex vertex)
        {
            List<Vertex> neighbours = new List<Vertex>();

            for (int i = -1; i < 2; i++)
            {
                for (int j = -1; j < 2; j++)
                {
                    if (i == 0 && j == 0)
                    {
                        continue;
                    }

                    Vertex neighbour = GetVertex(vertex.RowIndex + i, vertex.ColumnIndex + j);
                    if (neighbour != null && neighbour.TerrainType != TerrainType.NonWalkable)
                    {
                        if (i != 0 && j != 0)
                        {
                            Vertex cardinalNeighbour = GetVertex(vertex.RowIndex + i, vertex.ColumnIndex);
                            if (cardinalNeighbour != null && cardinalNeighbour.TerrainType != TerrainType.NonWalkable)
                            {
                                cardinalNeighbour = GetVertex(vertex.RowIndex, vertex.ColumnIndex + j);

                                if (cardinalNeighbour != null && cardinalNeighbour.TerrainType != TerrainType.NonWalkable)
                                {
                                    neighbours.Add(neighbour);
                                }
                            }
                        }
                        else
                        {
                            neighbours.Add(neighbour);
                        }
                    }
                }
            }

            return neighbours.ToArray();
        }

        private void ModifyVertexTerrainPenalty(Vertex vertex, int size, int value)
        {
            if (size > 0)
            {
                for (int i = -size; i <= size; i++)
                {
                    for (int j = -size; j <= size; j++)
                    {
                        if (_vertices.TryGetValue(CantorPairing(vertex.RowIndex + i, vertex.ColumnIndex + j), out Vertex neighbour))
                        {
                            neighbour.terrainPenalty += value;
                        }
                    }
                }
            }
            else
            {
                vertex.terrainPenalty += value;
            }
        }

        #region DEBUG

        private void OnDrawGizmos()
        {
            if (_settings && _centerTransform)
            {
                if (Application.isPlaying)
                {
                    if (_vertices != null)
                    {
                        foreach (Vertex vertex in _vertices.Values)
                        {
                            Gizmos.color = Vertex.GetColorBasedOnTerrainType(vertex.TerrainType, vertex.terrainPenalty);
                            Gizmos.DrawWireCube(vertex.Position, new Vector3(_vertexSize, 1, _vertexSize));
                        }
                    }

                    Vector2 mousePosition = Camera.main.ScreenToWorldPoint(Input.mousePosition);
                    Vertex selectedVertex = GetVertexOnPosition(mousePosition);

                    if (selectedVertex != null)
                    {
                        /*Handles.Label(selectedVertex.Position, $"{selectedVertex.terrainPenalty.ToString()}\n{selectedVertex.Identifier}", new GUIStyle() { alignment = TextAnchor.MiddleCenter });*/
                    }
                }

                // Draw Bounds
                Gizmos.color = Color.red;
                Gizmos.DrawWireCube(_centerTransform.position, new Vector3(_settings.GridSize.x, _startingPosition.y, _settings.GridSize.y));
            }
        }

        #endregion
    }
}